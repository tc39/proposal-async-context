<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<pre class="metadata">
title: AsyncContext
stage: 1
contributors: Chengzhong Wu, Justin Ridgewell
</pre>

<emu-clause id="sec-ecmascript-data-types-and-values">
  <h1>ECMAScript Data Types and Values</h1>

  <emu-clause id="sec-ecmascript-specification-types">
    <h1>ECMAScript Specification Types</h1>

    <ins class="block">
    <emu-clause id="sec-asynccontext-mapping-record-specification-type">
      <h1>The Async Context Mapping Record Specification Type</h1>
      <p>The <dfn variants="Async Context Mapping Records">Async Context Mapping Record</dfn> type is used to represent an AsyncContext.Variable value mapping in the surrounding Agent's [[AsyncContextMapping]].</p>
      <p>An Async Context Mapping Record's fields are defined by <emu-xref href="#table-asynccontext-mapping-record-fields"></emu-xref>.</p>

      <emu-table id="table-asynccontext-mapping-record-fields" caption="Async Context Mapping Record Fields">
        <table>
          <tr>
            <th>
              Field Name
            </th>
            <th>
              Value
            </th>
            <th>
              Meaning
            </th>
          </tr>
          <tr>
            <td>
              [[AsyncContextKey]]
            </td>
            <td>
              an AsyncContext.Variable instance
            </td>
            <td>
              The AsyncContext.Variable instance as the key in the mapping.
            </td>
          </tr>
          <tr>
            <td>
              [[AsyncContextValue]]
            </td>
            <td>
              an ECMAScript language value
            </td>
            <td>
              The value of the AsyncContext.Variable instance in the mapping.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>
    </ins>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-executable-code-and-execution-contexts">
  <h1>Executable Code and Execution Contexts</h1>

  <emu-clause id="sec-agents">
    <h1>Agents</h1>
    <p>This proposal adds a new field to the Agent Record as the following table:</p>
    <emu-table id="table-agent-record" caption="Agent Record Fields">
      <table>
        <tr>
          <th>Field Name</th>
          <th>Value</th>
          <th>Meaning</th>
        </tr>
        <tr>
          <td>[[LittleEndian]]</td>
          <td>a Boolean</td>
          <td>The default value computed for the <em>isLittleEndian</em> parameter when it is needed by the algorithms GetValueFromBuffer and SetValueInBuffer. The choice is implementation-defined and should be the alternative that is most efficient for the implementation. Once the value has been observed it cannot change.</td>
        </tr>
        <tr>
          <td>[[CanBlock]]</td>
          <td>a Boolean</td>
          <td>Determines whether the agent can block or not.</td>
        </tr>
        <tr>
          <td>[[Signifier]]</td>
          <td>an agent signifier</td>
          <td>Uniquely identifies the agent within its agent cluster.</td>
        </tr>
        <tr>
          <td>[[IsLockFree1]]</td>
          <td>a Boolean</td>
          <td>*true* if atomic operations on one-<emu-not-ref>byte values</emu-not-ref> are lock-free, *false* otherwise.</td>
        </tr>
        <tr>
          <td>[[IsLockFree2]]</td>
          <td>a Boolean</td>
          <td>*true* if atomic operations on two-<emu-not-ref>byte values</emu-not-ref> are lock-free, *false* otherwise.</td>
        </tr>
        <tr>
          <td>[[IsLockFree8]]</td>
          <td>a Boolean</td>
          <td>*true* if atomic operations on eight-<emu-not-ref>byte values</emu-not-ref> are lock-free, *false* otherwise.</td>
        </tr>
        <tr>
          <td>[[CandidateExecution]]</td>
          <td>a candidate execution Record</td>
          <td>See the memory model.</td>
        </tr>
        <tr>
          <td>[[KeptAlive]]</td>
          <td>a List of Objects</td>
          <td>Initially a new empty List, representing the list of objects to be kept alive until the end of the current Job</td>
        </tr>
        <tr>
          <td>
            <ins>[[AsyncContextMapping]]</ins>
          </td>
          <td>
            <ins>a List of Async Context Mapping Records</ins>
          </td>
          <td>
            <ins>A map from the AsyncContext.Variable instances to the saved ECMAScript language value. Every Record in the List contains a unique [[AsyncContextKey]]. The map is initially empty.</ins>
          </td>
        </tr>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-cleanup-finalization-registry" type="abstract operation">
    <h1>
      CleanupFinalizationRegistry (
        _finalizationRegistry_: a FinalizationRegistry,
      ): either a normal completion containing ~unused~ or a throw completion
    </h1>
    <dl class="header">
    </dl>
    <emu-alg>
      1. Assert: _finalizationRegistry_ has [[Cells]] and [[CleanupCallback]] internal slots.
      1. Let _callback_ be _finalizationRegistry_.[[CleanupCallback]].
      1. While _finalizationRegistry_.[[Cells]] contains a Record _cell_ such that _cell_.[[WeakRefTarget]] is ~empty~, an implementation may perform the following steps:
        1. Choose any such _cell_.
        1. Remove _cell_ from _finalizationRegistry_.[[Cells]].
        1. <del>Perform ? HostCallJobCallback(_callback_, *undefined*, « _cell_.[[HeldValue]] »).</del>
        1. <ins>Let _previousContextMapping_ be AsyncContextSwap(_cell_.[[AsyncContextSnapshot]]).</ins>
        1. <ins>Let _result_ be Completion(HostCallJobCallback(_callback_, *undefined*, « _cell_.[[HeldValue]] »)).</ins>
        1. <ins>AsyncContextSwap(_previousContextMapping_).</ins>
        1. <ins>Return _result_.</ins>
      1. Return ~unused~.
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-functions-and-classes">
  <h1>ECMAScript Language: Functions and Classes</h1>

  <emu-clause id="sec-generator-function-definitions">
    <h1>Generator Function Definitions</h1>

    <emu-clause id="sec-runtime-semantics-evaluategeneratorbody" oldids="sec-generator-function-definitions-runtime-semantics-evaluatebody" type="sdo">
      <h1>
        Runtime Semantics: EvaluateGeneratorBody (
          _functionObject_: a function object,
          _argumentsList_: a List of ECMAScript language values,
        ): a throw completion or a return completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>GeneratorBody : FunctionBody</emu-grammar>
      <emu-alg>
        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).
        1. Let _G_ be ? OrdinaryCreateFromConstructor(_functionObject_, *"%GeneratorFunction.prototype.prototype%"*, « [[GeneratorState]], [[GeneratorContext]], <ins>[[GeneratorAsyncContextMapping]],</ins> [[GeneratorBrand]] »).
        1. Set _G_.[[GeneratorBrand]] to ~empty~.
        1. Perform GeneratorStart(_G_, |FunctionBody|).
        1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _G_, [[Target]]: ~empty~ }.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-generator-function-definitions">
    <h1>Async Generator Function Definitions</h1>

    <emu-clause id="sec-runtime-semantics-evaluateasyncgeneratorbody" oldids="sec-asyncgenerator-definitions-evaluatebody" type="sdo">
      <h1>
        Runtime Semantics: EvaluateAsyncGeneratorBody (
          _functionObject_: a function object,
          _argumentsList_: a List of ECMAScript language values,
        ): a throw completion or a return completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncGeneratorBody : FunctionBody
      </emu-grammar>
      <emu-alg>
        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).
        1. Let _generator_ be ? OrdinaryCreateFromConstructor(_functionObject_, *"%AsyncGeneratorFunction.prototype.prototype%"*, « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], <ins>[[AsyncGeneratorAsyncContextMapping]],</ins> [[GeneratorBrand]] »).
        1. Set _generator_.[[GeneratorBrand]] to ~empty~.
        1. Perform AsyncGeneratorStart(_generator_, |FunctionBody|).
        1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _generator_, [[Target]]: ~empty~ }.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-control-abstraction-objects">
  <h1>Control Abstraction Objects</h1>

  <emu-clause id="sec-promise-objects">
    <h1>Promise Objects</h1>

    <emu-clause id="sec-promise-abstract-operations">
      <h1>Promise Abstract Operations</h1>

      <emu-clause id="sec-promisereaction-records">
        <h1>PromiseReaction Records</h1>
        <p>A <dfn variants="PromiseReaction Records">PromiseReaction Record</dfn> is a Record value used to store information about how a promise should react when it becomes resolved or rejected with a given value. PromiseReaction Records are created by the PerformPromiseThen abstract operation, and are used by the Abstract Closure returned by NewPromiseReactionJob.</p>
        <p>PromiseReaction Records have the fields listed in <emu-xref href="#table-promisereaction-record-fields"></emu-xref>.</p>
        <emu-table id="table-promisereaction-record-fields" caption="PromiseReaction Record Fields" oldids="table-58">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[Capability]]
              </td>
              <td>
                a PromiseCapability Record or *undefined*
              </td>
              <td>
                The capabilities of the promise for which this record provides a reaction handler.
              </td>
            </tr>
            <tr>
              <td>
                [[Type]]
              </td>
              <td>
                ~fulfill~ or ~reject~
              </td>
              <td>
                The [[Type]] is used when [[Handler]] is ~empty~ to allow for behaviour specific to the settlement type.
              </td>
            </tr>
            <tr>
              <td>
                [[Handler]]
              </td>
              <td>
                a JobCallback Record or ~empty~
              </td>
              <td>
                The function that should be applied to the incoming value, and whose return value will govern what happens to the derived promise. If [[Handler]] is ~empty~, a function that depends on the value of [[Type]] will be used instead.
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[AsyncContextSnapshot]]</ins>
              </td>
              <td>
                <ins>a List of Async Context Mapping Records</ins>
              </td>
              <td>
                <ins>A map from the AsyncContext.Variable instances to the saved ECMAScript language value. Every Record in the List contains a unique [[AsyncContextKey]].</ins>
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-host-promise-rejection-tracker" type="host-defined abstract operation">
        <h1>
          HostPromiseRejectionTracker (
            _promise_: a Promise,
            _operation_: *"reject"* or *"handle"*,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It allows host environments to track promise rejections.</dd>
        </dl>
        <p>An implementation of HostPromiseRejectionTracker must conform to the following requirements:</p>
        <ul>
          <li>It must complete normally (i.e. not return an abrupt completion).</li>
        </ul>
        <p>The default implementation of HostPromiseRejectionTracker is to return ~unused~.</p>

        <ins class="block">
          <emu-note>
            <p>An implementation of HostPromiseRejectionTracker that delays notifying developers of unhandled rejections must conform to the following requirements</p>
            <ul>
              <li>It must perform AsyncContextSnapshot() at the call of HostPromiseRejectionTracker,</li>
              <li>It must perform AsyncContextSwap before the event notification, with the result of the AsyncContextSnapshot operation,</li>
              <li>It must perform AsyncContextSwap after the event notification, with the result of the earlier AsyncContextSwap operation.</li>
            </ul>
          </emu-note>
        </ins>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-promise-jobs">
      <h1>Promise Jobs</h1>
      <emu-clause id="sec-newpromisereactionjob" type="abstract operation" oldids="sec-promisereactionjob">
        <h1>
          NewPromiseReactionJob (
            _reaction_: a PromiseReaction Record,
            _argument_: an ECMAScript language value,
          ): a Record with fields [[Job]] (a Job Abstract Closure) and [[Realm]] (a Realm Record or *null*)
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It returns a new Job Abstract Closure that applies the appropriate handler to the incoming value, and uses the handler's return value to resolve or reject the derived promise associated with that handler.</dd>
        </dl>
        <emu-alg>
          1. Let _job_ be a new Job Abstract Closure with no parameters that captures _reaction_ and _argument_ and performs the following steps when called:
            1. Let _promiseCapability_ be _reaction_.[[Capability]].
            1. Let _type_ be _reaction_.[[Type]].
            1. Let _handler_ be _reaction_.[[Handler]].
            1. <ins>Let _previousContextMapping_ be AsyncContextSwap(_reaction_.[[AsyncContextSnapshot]]).</ins>
            1. If _handler_ is ~empty~, then
              1. If _type_ is ~Fulfill~, let _handlerResult_ be NormalCompletion(_argument_).
              1. Else,
                1. Assert: _type_ is ~Reject~.
                1. Let _handlerResult_ be ThrowCompletion(_argument_).
            1. Else, let _handlerResult_ be Completion(HostCallJobCallback(_handler_, *undefined*, « _argument_ »)).
            1. If _promiseCapability_ is *undefined*, then
              1. Assert: _handlerResult_ is not an abrupt completion.
              1. <ins>AsyncContextSwap(_previousContextMapping_).</ins>
              1. Return ~empty~.
            1. Assert: _promiseCapability_ is a PromiseCapability Record.
            1. If _handlerResult_ is an abrupt completion, then
              1. <del>Return ? Call(_promiseCapability_.[[Reject]], *undefined*, « _handlerResult_.[[Value]] »).</del>
              1. <ins>Let _resolvingFunctionResult_ be Completion(Call(_promiseCapability_.[[Reject]], *undefined*, « _handlerResult_.[[Value]] »)).</ins>
            1. Else,
              1. <del>Return ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _handlerResult_.[[Value]] »).</del>
              1. <ins>Let _resolvingFunctionResult_ be Completion(Call(_promiseCapability_.[[Resolve]], *undefined*, « _handlerResult_.[[Value]] »)).</ins>
            1. <ins>AsyncContextSwap(_previousContextMapping_).</ins>
            1. <ins>Return _resolvingFunctionResult_.</ins>
          1. Let _handlerRealm_ be *null*.
          1. If _reaction_.[[Handler]] is not ~empty~, then
            1. Let _getHandlerRealmResult_ be Completion(GetFunctionRealm(_reaction_.[[Handler]].[[Callback]])).
            1. If _getHandlerRealmResult_ is a normal completion, set _handlerRealm_ to _getHandlerRealmResult_.[[Value]].
            1. Else, set _handlerRealm_ to the current Realm Record.
            1. NOTE: _handlerRealm_ is never *null* unless the handler is *undefined*. When the handler is a revoked Proxy and no ECMAScript code runs, _handlerRealm_ is used to create error objects.
          1. Return the Record { [[Job]]: _job_, [[Realm]]: _handlerRealm_ }.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-newpromiseresolvethenablejob" type="abstract operation" oldids="sec-promiseresolvethenablejob">
        <h1>
          NewPromiseResolveThenableJob (
            _promiseToResolve_: a Promise,
            _thenable_: an Object,
            _then_: a JobCallback Record,
          ): a Record with fields [[Job]] (a Job Abstract Closure) and [[Realm]] (a Realm Record)
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. <ins>Let _snapshot_ be AsyncContextSnapshot().</ins>
          1. Let _job_ be a new Job Abstract Closure with no parameters that captures _promiseToResolve_, _thenable_, _then_, <ins>and _snapshot_</ins> and performs the following steps when called:
            1. Let _resolvingFunctions_ be CreateResolvingFunctions(_promiseToResolve_).
            1. <ins>Let _previousContextMapping_ be AsyncContextSwap(_snapshot_).</ins>
            1. Let _thenCallResult_ be Completion(HostCallJobCallback(_then_, _thenable_, « _resolvingFunctions_.[[Resolve]], _resolvingFunctions_.[[Reject]] »)).
            1. If _thenCallResult_ is an abrupt completion, then
              1. <del>Return ? Call(_resolvingFunctions_.[[Reject]], *undefined*, « _thenCallResult_.[[Value]] »).</del>
              1. <ins>Let _rejectResult_ be Completion(Call(_resolvingFunctions_.[[Reject]], *undefined*, « _thenCallResult_.[[Value]] »)).</ins>
              1. <ins>AsyncContextSwap(_previousContextMapping_).</ins>
              1. <ins>Return _rejectResult_.</ins>
            1. <ins>AsyncContextSwap(_previousContextMapping_).</ins>
            1. Return ? _thenCallResult_.
          1. Let _getThenRealmResult_ be Completion(GetFunctionRealm(_then_.[[Callback]])).
          1. If _getThenRealmResult_ is a normal completion, let _thenRealm_ be _getThenRealmResult_.[[Value]].
          1. Else, let _thenRealm_ be the current Realm Record.
          1. NOTE: _thenRealm_ is never *null*. When _then_.[[Callback]] is a revoked Proxy and no code runs, _thenRealm_ is used to create error objects.
          1. Return the Record { [[Job]]: _job_, [[Realm]]: _thenRealm_ }.
        </emu-alg>
        <emu-note>
          <p>This Job uses the supplied thenable and its `then` method to resolve the given promise. This process must take place as a Job to ensure that the evaluation of the `then` method occurs after evaluation of any surrounding code has completed.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-promise-prototype-object">
      <h1>Properties of the Promise Prototype Object</h1>
      <p>The <dfn>Promise prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%Promise.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[PromiseState]] internal slot or any of the other internal slots of Promise instances.</li>
      </ul>

      <emu-clause id="sec-promise.prototype.then">
        <h1>Promise.prototype.then ( _onFulfilled_, _onRejected_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _promise_ be the *this* value.
          1. If IsPromise(_promise_) is *false*, throw a *TypeError* exception.
          1. Let _C_ be ? SpeciesConstructor(_promise_, %Promise%).
          1. Let _resultCapability_ be ? NewPromiseCapability(_C_).
          1. Return PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_, _resultCapability_).
        </emu-alg>

        <emu-clause id="sec-performpromisethen" type="abstract operation">
          <h1>
            PerformPromiseThen (
              _promise_: a Promise,
              _onFulfilled_: an ECMAScript language value,
              _onRejected_: an ECMAScript language value,
              optional _resultCapability_: a PromiseCapability Record,
            ): an ECMAScript language value
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It performs the “then” operation on _promise_ using _onFulfilled_ and _onRejected_ as its settlement actions. If _resultCapability_ is passed, the result is stored by updating _resultCapability_'s promise. If it is not passed, then PerformPromiseThen is being called by a specification-internal operation where the result does not matter.</dd>
          </dl>
          <emu-alg>
            1. Assert: IsPromise(_promise_) is *true*.
            1. If _resultCapability_ is not present, then
              1. Set _resultCapability_ to *undefined*.
            1. If IsCallable(_onFulfilled_) is *false*, then
              1. Let _onFulfilledJobCallback_ be ~empty~.
            1. Else,
              1. Let _onFulfilledJobCallback_ be HostMakeJobCallback(_onFulfilled_).
            1. If IsCallable(_onRejected_) is *false*, then
              1. Let _onRejectedJobCallback_ be ~empty~.
            1. Else,
              1. Let _onRejectedJobCallback_ be HostMakeJobCallback(_onRejected_).
            1. <ins>Let _snapshot_ be AsyncContextSnapshot().</ins>
            1. Let _fulfillReaction_ be the PromiseReaction Record { [[Capability]]: _resultCapability_, [[Type]]: ~fulfill~, [[Handler]]: _onFulfilledJobCallback_, <ins>[[AsyncContextSnapshot]]: _snapshot_</ins> }.
            1. Let _rejectReaction_ be the PromiseReaction Record { [[Capability]]: _resultCapability_, [[Type]]: ~reject~, [[Handler]]: _onRejectedJobCallback_, <ins>[[AsyncContextSnapshot]]: _snapshot_</ins>}.
            1. If _promise_.[[PromiseState]] is ~pending~, then
              1. Append _fulfillReaction_ to _promise_.[[PromiseFulfillReactions]].
              1. Append _rejectReaction_ to _promise_.[[PromiseRejectReactions]].
            1. Else if _promise_.[[PromiseState]] is ~fulfilled~, then
              1. Let _value_ be _promise_.[[PromiseResult]].
              1. Let _fulfillJob_ be NewPromiseReactionJob(_fulfillReaction_, _value_).
              1. Perform HostEnqueuePromiseJob(_fulfillJob_.[[Job]], _fulfillJob_.[[Realm]]).
            1. Else,
              1. Assert: The value of _promise_.[[PromiseState]] is ~rejected~.
              1. Let _reason_ be _promise_.[[PromiseResult]].
              1. If _promise_.[[PromiseIsHandled]] is *false*, perform HostPromiseRejectionTracker(_promise_, *"handle"*).
              1. Let _rejectJob_ be NewPromiseReactionJob(_rejectReaction_, _reason_).
              1. Perform HostEnqueuePromiseJob(_rejectJob_.[[Job]], _rejectJob_.[[Realm]]).
            1. Set _promise_.[[PromiseIsHandled]] to *true*.
            1. If _resultCapability_ is *undefined*, then
              1. Return *undefined*.
            1. Else,
              1. Return _resultCapability_.[[Promise]].
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-generator-objects">
    <h1>Generator Objects</h1>

    <emu-clause id="sec-properties-of-generator-instances">
      <h1>Properties of Generator Instances</h1>
      <p>Generator instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-generator-instances"></emu-xref>.</p>
      <emu-table id="table-internal-slots-of-generator-instances" caption="Internal Slots of Generator Instances" oldids="table-56">
        <table>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Type
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[GeneratorState]]
            </td>
            <td>
              *undefined*, ~suspendedStart~, ~suspendedYield~, ~executing~, or ~completed~
            </td>
            <td>
              The current execution state of the generator.
            </td>
          </tr>
          <tr>
            <td>
              [[GeneratorContext]]
            </td>
            <td>
              an execution context
            </td>
            <td>
              The execution context that is used when executing the code of this generator.
            </td>
          </tr>
          <tr>
            <td>
              <ins>[[GeneratorAsyncContextMapping]]</ins>
            </td>
            <td>
              <ins>a List of Async Context Mapping Records</ins>
            </td>
            <td>
              <ins>The value of the agent's [[AsyncContextMapping]] to use the next time this generator is resumed.</ins>
            </td>
          </tr>
          <tr>
            <td>
              [[GeneratorBrand]]
            </td>
            <td>
              a String or ~empty~
            </td>
            <td>
              A brand used to distinguish different kinds of generators. The [[GeneratorBrand]] of generators declared by ECMAScript source text is always ~empty~.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-generator-abstract-operations">
      <h1>Generator Abstract Operations</h1>

      <emu-clause id="sec-generatorstart" type="abstract operation">
        <h1>
          GeneratorStart (
            _generator_: a Generator,
            _generatorBody_: a |FunctionBody| Parse Node or an Abstract Closure with no parameters,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: The value of _generator_.[[GeneratorState]] is *undefined*.
          1. Let _genContext_ be the running execution context.
          1. Set the Generator component of _genContext_ to _generator_.
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _generatorBody_ and performs the following steps when called:
            1. Let _acGenContext_ be the running execution context.
            1. Let _acGenerator_ be the Generator component of _acGenContext_.
            1. If _generatorBody_ is a Parse Node, then
              1. Let _result_ be Completion(Evaluation of _generatorBody_).
            1. Else,
              1. Assert: _generatorBody_ is an Abstract Closure with no parameters.
              1. Let _result_ be _generatorBody_().
            1. Assert: If we return here, the generator either threw an exception or performed either an implicit or explicit return.
            1. Remove _acGenContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
            1. Set _acGenerator_.[[GeneratorState]] to ~completed~.
            1. NOTE: Once a generator enters the ~completed~ state it never leaves it and its associated execution context is never resumed. Any execution state associated with _acGenerator_ can be discarded at this point.
            1. If _result_.[[Type]] is ~normal~, then
              1. Let _resultValue_ be *undefined*.
            1. Else if _result_.[[Type]] is ~return~, then
              1. Let _resultValue_ be _result_.[[Value]].
            1. Else,
              1. Assert: _result_.[[Type]] is ~throw~.
              1. Return ? _result_.
            1. Return CreateIterResultObject(_resultValue_, *true*).
          1. Set the code evaluation state of _genContext_ such that when evaluation is resumed for that execution context, _closure_ will be called with no arguments.
          1. Set _generator_.[[GeneratorContext]] to _genContext_.
          1. <ins>Set _generator_.[[GeneratorAsyncContextMapping]] to AsyncContextSnapshot().</ins>
          1. Set _generator_.[[GeneratorState]] to ~suspendedStart~.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatorvalidate" type="abstract operation">
        <h1>
          GeneratorValidate (
            _generator_: an ECMAScript language value,
            _generatorBrand_: a String or ~empty~,
          ): either a normal completion containing one of ~suspendedStart~, ~suspendedYield~, or ~completed~, or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Perform ? RequireInternalSlot(_generator_, [[GeneratorState]]).
          1. Perform ? RequireInternalSlot(_generator_, [[GeneratorBrand]]).
          1. If _generator_.[[GeneratorBrand]] is not _generatorBrand_, throw a *TypeError* exception.
          1. <del>Assert: _generator_ also has a [[GeneratorContext]] internal slot.</del>
          1. <ins>Assert: _generator_ also has [[GeneratorContext]] and [[GeneratorAsyncContextMapping]] internal slots.</ins>
          1. Let _state_ be _generator_.[[GeneratorState]].
          1. If _state_ is ~executing~, throw a *TypeError* exception.
          1. Return _state_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatorresume" type="abstract operation">
        <h1>
          GeneratorResume (
            _generator_: an ECMAScript language value,
            _value_: an ECMAScript language value or ~empty~,
            _generatorBrand_: a String or ~empty~,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _state_ be ? GeneratorValidate(_generator_, _generatorBrand_).
          1. If _state_ is ~completed~, return CreateIterResultObject(*undefined*, *true*).
          1. Assert: _state_ is either ~suspendedStart~ or ~suspendedYield~.
          1. Let _genContext_ be _generator_.[[GeneratorContext]].
          1. Let _methodContext_ be the running execution context.
          1. Suspend _methodContext_.
          1. Set _generator_.[[GeneratorState]] to ~executing~.
          1. <ins>Let _asyncContextMapping_ be AsyncContextSwap(_generator_.[[GeneratorAsyncContextMapping]]).</ins>
          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.
          1. <emu-meta effects="user-code">Resume the suspended evaluation of _genContext_</emu-meta> using NormalCompletion(_value_) as the result of the operation that suspended it. Let _result_ be the value returned by the resumed computation.
          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _methodContext_ is the currently running execution context.
          1. <ins>Assert: The result of AsyncContextSnapshot() is _generator_.[[GeneratorAsyncContextMapping]].</ins>
          1. <ins>AsyncContextSwap(_asyncContextMapping_).</ins>
          1. Return ? _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatorresumeabrupt" type="abstract operation">
        <h1>
          GeneratorResumeAbrupt (
            _generator_: an ECMAScript language value,
            _abruptCompletion_: a return completion or a throw completion,
            _generatorBrand_: a String or ~empty~,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _state_ be ? GeneratorValidate(_generator_, _generatorBrand_).
          1. If _state_ is ~suspendedStart~, then
            1. Set _generator_.[[GeneratorState]] to ~completed~.
            1. NOTE: Once a generator enters the ~completed~ state it never leaves it and its associated execution context is never resumed. Any execution state associated with _generator_ can be discarded at this point.
            1. Set _state_ to ~completed~.
          1. If _state_ is ~completed~, then
            1. If _abruptCompletion_.[[Type]] is ~return~, then
              1. Return CreateIterResultObject(_abruptCompletion_.[[Value]], *true*).
            1. Return ? _abruptCompletion_.
          1. Assert: _state_ is ~suspendedYield~.
          1. Let _genContext_ be _generator_.[[GeneratorContext]].
          1. Let _methodContext_ be the running execution context.
          1. Suspend _methodContext_.
          1. Set _generator_.[[GeneratorState]] to ~executing~.
          1. <ins>Let _asyncContextMapping_ be AsyncContextSwap(_generator_.[[GeneratorAsyncContextMapping]]).</ins>
          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.
          1. <emu-meta effects="user-code">Resume the suspended evaluation of _genContext_</emu-meta> using _abruptCompletion_ as the result of the operation that suspended it. Let _result_ be the Completion Record returned by the resumed computation.
          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _methodContext_ is the currently running execution context.
          1. <ins>Assert: The result of AsyncContextSnapshot() is _generator_.[[GeneratorAsyncContextMapping]].</ins>
          1. <ins>AsyncContextSwap(_asyncContextMapping_).</ins>
          1. Return ? _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createiteratorfromclosure" type="abstract operation">
        <h1>
          CreateIteratorFromClosure (
            _closure_: an Abstract Closure with no parameters,
            _generatorBrand_: a String or ~empty~,
            _generatorPrototype_: an Object,
          ): a Generator
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. NOTE: _closure_ can contain uses of the Yield operation to yield an IteratorResult object.
          1. Let _internalSlotsList_ be « [[GeneratorState]], [[GeneratorContext]], <ins>[[GeneratorAsyncContextMapping]],</ins> [[GeneratorBrand]] ».
          1. Let _generator_ be OrdinaryObjectCreate(_generatorPrototype_, _internalSlotsList_).
          1. Set _generator_.[[GeneratorBrand]] to _generatorBrand_.
          1. Set _generator_.[[GeneratorState]] to *undefined*.
          1. Let _callerContext_ be the running execution context.
          1. Let _calleeContext_ be a new execution context.
          1. Set the Function of _calleeContext_ to *null*.
          1. Set the Realm of _calleeContext_ to the current Realm Record.
          1. Set the ScriptOrModule of _calleeContext_ to _callerContext_'s ScriptOrModule.
          1. If _callerContext_ is not already suspended, suspend _callerContext_.
          1. Push _calleeContext_ onto the execution context stack; _calleeContext_ is now the running execution context.
          1. Perform GeneratorStart(_generator_, _closure_).
          1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.
          1. Return _generator_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-asyncgenerator-objects">
    <h1>AsyncGenerator Objects</h1>

    <emu-clause id="sec-properties-of-asyncgenerator-intances">
      <h1>Properties of AsyncGenerator Instances</h1>
      <p>AsyncGenerator instances are initially created with the internal slots described below:</p>
      <emu-table id="table-internal-slots-of-asyncgenerator-instances" caption="Internal Slots of AsyncGenerator Instances">
        <table>
          <tr>
            <th>Internal Slot</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>[[AsyncGeneratorState]]</td>
            <td>*undefined*, ~suspendedStart~, ~suspendedYield~, ~executing~, ~awaiting-return~, or ~completed~</td>
            <td>The current execution state of the async generator.</td>
          </tr>
          <tr>
            <td>[[AsyncGeneratorContext]]</td>
            <td>an execution context</td>
            <td>The execution context that is used when executing the code of this async generator.</td>
          </tr>
          <tr>
            <td>[[AsyncGeneratorQueue]]</td>
            <td>a List of AsyncGeneratorRequest Records</td>
            <td>Records which represent requests to resume the async generator. Except during state transitions, it is non-empty if and only if [[AsyncGeneratorState]] is either ~executing~ or ~awaiting-return~.</td>
          </tr>
          <tr>
            <td><ins>[[AsyncGeneratorAsyncContextMapping]]</ins></td>
            <td><ins>a List of Async Context Mapping Records</ins></td>
            <td><ins>The value of the agent's [[AsyncContextMapping]] to use the next time this generator is resumed.</ins></td>
          </tr>
          <tr>
            <td>[[GeneratorBrand]]</td>
            <td>a String or ~empty~</td>
            <td>A brand used to distinguish different kinds of async generators. The [[GeneratorBrand]] of async generators declared by ECMAScript source text is always ~empty~.</td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-asyncgenerator-abstract-operations">
      <h1>AsyncGenerator Abstract Operations</h1>

      <emu-clause id="sec-asyncgeneratorstart" type="abstract operation">
        <h1>
          AsyncGeneratorStart (
            _generator_: an AsyncGenerator,
            _generatorBody_: a |FunctionBody| Parse Node or an Abstract Closure with no parameters,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _generator_.[[AsyncGeneratorState]] is *undefined*.
          1. Let _genContext_ be the running execution context.
          1. Set the Generator component of _genContext_ to _generator_.
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _generatorBody_ and performs the following steps when called:
            1. Let _acGenContext_ be the running execution context.
            1. Let _acGenerator_ be the Generator component of _acGenContext_.
            1. If _generatorBody_ is a Parse Node, then
              1. Let _result_ be Completion(Evaluation of _generatorBody_).
            1. Else,
              1. Assert: _generatorBody_ is an Abstract Closure with no parameters.
              1. Let _result_ be Completion(_generatorBody_()).
            1. Assert: If we return here, the async generator either threw an exception or performed either an implicit or explicit return.
            1. Remove _acGenContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
            1. Set _acGenerator_.[[AsyncGeneratorState]] to ~completed~.
            1. If _result_.[[Type]] is ~normal~, set _result_ to NormalCompletion(*undefined*).
            1. If _result_.[[Type]] is ~return~, set _result_ to NormalCompletion(_result_.[[Value]]).
            1. Perform AsyncGeneratorCompleteStep(_acGenerator_, _result_, *true*).
            1. Perform AsyncGeneratorDrainQueue(_acGenerator_).
            1. Return *undefined*.
          1. Set the code evaluation state of _genContext_ such that when evaluation is resumed for that execution context, _closure_ will be called with no arguments.
          1. Set _generator_.[[AsyncGeneratorContext]] to _genContext_.
          1. Set _generator_.[[AsyncGeneratorState]] to ~suspendedStart~.
          1. Set _generator_.[[AsyncGeneratorQueue]] to a new empty List.
          1. <ins>Set _generator_.[[AsyncGeneratorAsyncContextMapping]] to AsyncContextSnapshot().</ins>
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorvalidate" type="abstract operation">
        <h1>
          AsyncGeneratorValidate (
            _generator_: an ECMAScript language value,
            _generatorBrand_: a String or ~empty~,
          ): either a normal completion containing ~unused~ or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Perform ? RequireInternalSlot(_generator_, [[AsyncGeneratorContext]]).
          1. Perform ? RequireInternalSlot(_generator_, [[AsyncGeneratorState]]).
          1. Perform ? RequireInternalSlot(_generator_, [[AsyncGeneratorQueue]]).
          1. <ins>Perform ? RequireInternalSlot(_generator_, [[AsyncGeneratorAsyncContextMapping]]).</ins>
          1. If _generator_.[[GeneratorBrand]] is not _generatorBrand_, throw a *TypeError* exception.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorresume" type="abstract operation">
        <h1>
          AsyncGeneratorResume (
            _generator_: an AsyncGenerator,
            _completion_: a Completion Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _generator_.[[AsyncGeneratorState]] is either ~suspendedStart~ or ~suspendedYield~.
          1. Let _genContext_ be _generator_.[[AsyncGeneratorContext]].
          1. Let _callerContext_ be the running execution context.
          1. Suspend _callerContext_.
          1. Set _generator_.[[AsyncGeneratorState]] to ~executing~.
          1. <ins>Let _asyncContextMapping_ be AsyncContextSwap(_generator_.[[AsyncGeneratorAsyncContextMapping]]).</ins>
          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.
          1. <emu-meta effects="user-code">Resume the suspended evaluation of _genContext_</emu-meta> using _completion_ as the result of the operation that suspended it. Let _result_ be the Completion Record returned by the resumed computation.
          1. Assert: _result_ is never an abrupt completion.
          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _callerContext_ is the currently running execution context.
          1. <ins>Assert: The result of AsyncContextSnapshot() is _generator_.[[AsyncGeneratorAsyncContextMapping]].</ins>
          1. <ins>AsyncContextSwap(_asyncContextMapping_).</ins>
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createasynciteratorfromclosure" type="abstract operation">
        <h1>
          CreateAsyncIteratorFromClosure (
            _closure_: an Abstract Closure with no parameters,
            _generatorBrand_: a String or ~empty~,
            _generatorPrototype_: an Object,
          ): an AsyncGenerator
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. NOTE: _closure_ can contain uses of the Await operation and uses of the Yield operation to yield an IteratorResult object.
          1. Let _internalSlotsList_ be « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], <ins>[[AsyncGeneratorAsyncContextMapping]],</ins> [[GeneratorBrand]] ».
          1. Let _generator_ be OrdinaryObjectCreate(_generatorPrototype_, _internalSlotsList_).
          1. Set _generator_.[[GeneratorBrand]] to _generatorBrand_.
          1. Set _generator_.[[AsyncGeneratorState]] to *undefined*.
          1. Let _callerContext_ be the running execution context.
          1. Let _calleeContext_ be a new execution context.
          1. Set the Function of _calleeContext_ to *null*.
          1. Set the Realm of _calleeContext_ to the current Realm Record.
          1. Set the ScriptOrModule of _calleeContext_ to _callerContext_'s ScriptOrModule.
          1. If _callerContext_ is not already suspended, suspend _callerContext_.
          1. Push _calleeContext_ onto the execution context stack; _calleeContext_ is now the running execution context.
          1. Perform AsyncGeneratorStart(_generator_, _closure_).
          1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.
          1. Return _generator_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <ins class="block">
  <emu-clause id="sec-asynccontext-object">
    <h1>The AsyncContext Object</h1>
    <p>The AsyncContext object:</p>
    <ul>
      <li>is the intrinsic object <dfn>%AsyncContext%</dfn>.</li>
      <li>is the initial value of the *"AsyncContext"* property of the global object.</li>
      <li>is an ordinary object.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      <li>is not a function object.</li>
      <li>does not have a [[Construct]] internal method; it cannot be used as a constructor with the `new` operator.</li>
      <li>does not have a [[Call]] internal method; it cannot be invoked as a function.</li>
    </ul>

    <emu-clause id="sec-asynccontext-abstract-operations">
      <h1>AsyncContext Abstract Operations</h1>
      <emu-clause id="sec-asynccontextsnapshot" type="abstract operation">
        <h1>
          AsyncContextSnapshot (
          ): a List of Async Context Mapping Records
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used to snapshot the surrounding agent's Agent Record's [[AsyncContextMapping]].</dd>
        </dl>
        <emu-alg>
          1. Let _agentRecord_ be the surrounding agent's Agent Record.
          1. Return _agentRecord_.[[AsyncContextMapping]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asynccontextswap" type="abstract operation">
        <h1>
          AsyncContextSwap (
            _snapshotMapping_: a List of Async Context Mapping Records
          ): a List of Async Context Mapping Records
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used to swap the surrounding agent's Agent Record's [[AsyncContextMapping]] with the _snapshotMapping_.</dd>
        </dl>
        <emu-alg>
          1. Let _agentRecord_ be the surrounding agent's Agent Record.
          1. Let _asyncContextMapping_ be _agentRecord_.[[AsyncContextMapping]].
          1. Set _agentRecord_.[[AsyncContextMapping]] to _snapshotMapping_.
          1. Return _asyncContextMapping_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-asynccontext-object">
      <h1>Constructor Properties of the AsyncContext Object</h1>

      <emu-clause id="sec-asynccontext.snapshot">
        <h1>AsyncContext.Snapshot ( . . . )</h1>
        <p>See <emu-xref href="#sec-asynccontext-snapshot-objects"></emu-xref>.</p>
      </emu-clause>

      <emu-clause id="sec-asynccontext.variable">
        <h1>AsyncContext.Variable ( . . . )</h1>
        <p>See <emu-xref href="#sec-asynccontext-variable-objects"></emu-xref>.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-value-properties-of-the-asynccontext-object">
      <h1>Value Properties of the AsyncContext Object</h1>

      <emu-clause id="sec-asynccontext-@@tostringtag">
        <h1>AsyncContext [ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value *"AsyncContext"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-asynccontext-snapshot-objects">
    <h1>AsyncContext.Snapshot Objects</h1>

    <emu-clause id="sec-asynccontext-snapshot-constructor">
      <h1>The AsyncContext.Snapshot Constructor</h1>
      <p>The AsyncContext.Snapshot constructor:</p>
      <ul>
        <li>is <dfn>%AsyncContext.Snapshot%</dfn>.</li>
        <li>is the initial value of the *"Snapshot"* property of the %AsyncContext% object.</li>
        <li>creates and initializes a new AsyncContext.Snapshot when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified AsyncContext.Snapshot behaviour must include a `super` call to the AsyncContext.Snapshot constructor to create and initialize the subclass instance with the internal state necessary to support the `AsyncContext.Snapshot` and `AsyncContext.Snapshot.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-asynccontext-snapshot">
        <h1>AsyncContext.Snapshot ( )</h1>
        <p>This function performs the following steps when called:</p>

        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _snapshotMapping_ be AsyncContextSnapshot().
          1. Let _asyncSnapshot_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%AsyncContext.Snapshot.prototype%"*, « [[AsyncSnapshotMapping]] »).
          1. Set _asyncSnapshot_.[[AsyncSnapshotMapping]] to _snapshotMapping_.
          1. Return _asyncSnapshot_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-asynccontext-snapshot-constructor">
      <h1>Properties of the AsyncContext.Snapshot Constructor</h1>
      <p>The AsyncContext.Snapshot constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-asynccontext-snapshot.prototype">
        <h1>AsyncContext.Snapshot.prototype</h1>
        <p>The initial value of `AsyncContext.Snapshot.prototype` is the AsyncContext.Snapshot prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-asynccontext-snapshot-prototype-object">
      <h1>Properties of the AsyncContext.Snapshot Prototype Object</h1>
      <p>The <dfn>AsyncContext.Snapshot prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%AsyncContext.Snapshot.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have any of the other internal slots of AsyncContext.Snapshot instances.</li>
      </ul>

      <emu-clause id="sec-asynccontext-snapshot.prototype.constructor">
        <h1>AsyncContext.Snapshot.prototype.constructor</h1>
        <p>The initial value of `AsyncContext.Snapshot.prototype.constructor` is %AsyncContext.Snapshot%.</p>
      </emu-clause>

      <emu-clause id="sec-asynccontext-snapshot.prototype.run">
        <h1>AsyncContext.Snapshot.prototype.run ( _func_, ..._args_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _asyncSnapshot_ be the *this* value.
          1. Perform ? RequireInternalSlot(_asyncSnapshot_, [[AsyncSnapshotMapping]]).
          1. Let _previousContextMapping_ be AsyncContextSwap(_asyncSnapshot_.[[AsyncSnapshotMapping]]).
          1. Let _result_ be Completion(Call(_func_, *undefined*, _args_)).
          1. AsyncContextSwap(_previousContextMapping_).
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asynccontext-snapshot.prototype-@@tostringtag">
        <h1>AsyncContext.Snapshot.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value *"AsyncContext.Snapshot"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-asynccontext-snapshot-instances">
      <h1>Properties of AsyncContext.Snapshot Instances</h1>
      <p>AsyncContext.Snapshot instances are ordinary objects that inherit properties from the AsyncContext.Snapshot prototype object (the intrinsic, %AsyncContext.Snapshot.prototype%). AsyncContext.Snapshot instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-asynccontext-snapshot-instances"></emu-xref>.</p>

      <emu-table id="table-internal-slots-of-asynccontext-snapshot-instances" caption="Internal Slots of AsyncContext-Snapshot Instances">
        <table>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Type
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[AsyncSnapshotMapping]]
            </td>
            <td>
              a List of Async Context Mapping Records
            </td>
            <td>
              Represents the snapshotted surrounding agent's Agent Record's [[AsyncContextMapping]] of the AsyncContext.Snapshot instance.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-asynccontext-variable-objects">
    <h1>AsyncContext.Variable Objects</h1>

    <emu-clause id="sec-asynccontext-variable-constructor">
      <h1>The AsyncContext.Variable Constructor</h1>
      <p>The AsyncContext.Variable constructor:</p>
      <ul>
        <li>is <dfn>%AsyncContext.Variable%</dfn>.</li>
        <li>is the initial value of the *"Variable"* property of the %AsyncContext% object.</li>
        <li>creates and initializes a new AsyncContext.Variable when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified AsyncContext.Variable behaviour must include a `super` call to the AsyncContext.Variable constructor to create and initialize the subclass instance with the internal state necessary to support the `AsyncContext.Variable.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-asynccontext-variable">
        <h1>AsyncContext.Variable ( _options_ )</h1>
        <p>This function performs the following steps when called:</p>

        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _nameStr_ be the empty String.
          1. Let _defaultValue_ be *undefined*.
          1. If _options_ is an Object, then
            1. Let _namePresent_ be ? HasProperty(_options_, *"name"*).
            1. If _namePresent_ is *true*, then
              1. Let _name_ be ? Get(_options_, *"name"*).
              1. Set _nameStr_ to ? ToString(_name_).
            1. Set _defaultValue_ to ? Get(_options_, *"defaultValue"*).
          1. Let _asyncVariable_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%AsyncContext.Variable.prototype%"*, « [[AsyncVariableName]], [[AsyncVariableDefaultValue]] »).
          1. Set _asyncVariable_.[[AsyncVariableName]] to _nameStr_.
          1. Set _asyncVariable_.[[AsyncVariableDefaultValue]] to _defaultValue_.
          1. Return _asyncVariable_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-asynccontext-variable-constructor">
      <h1>Properties of the AsyncContext.Variable Constructor</h1>
      <p>The AsyncContext.Variable constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-asynccontext-variable.prototype">
        <h1>AsyncContext.Variable.prototype</h1>
        <p>The initial value of `AsyncContext.Variable.prototype` is the AsyncContext.Variable prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-asynccontext-variable-prototype-object">
      <h1>Properties of the AsyncContext.Variable Prototype Object</h1>
      <p>The <dfn>AsyncContext.Variable prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%AsyncContext.Variable.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have any of the other internal slots of AsyncContext.Variable instances.</li>
      </ul>

      <emu-clause id="sec-asynccontext-variable.prototype.constructor">
        <h1>AsyncContext.Variable.prototype.constructor</h1>
        <p>The initial value of `AsyncContext.Variable.prototype.constructor` is %AsyncContext.Variable%.</p>
      </emu-clause>

      <emu-clause id="sec-asynccontext-variable.prototype.run">
        <h1>AsyncContext.Variable.prototype.run ( _value_, _func_, ..._args_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _asyncVariable_ be the *this* value.
          1. Perform ? RequireInternalSlot(_asyncVariable_, [[AsyncVariableName]]).
          1. Let _previousContextMapping_ be AsyncContextSnapshot().
          1. Let _asyncContextMapping_ be a new empty List.
          1. For each Async Context Mapping Record _p_ of _previousContextMapping_, do
            1. If SameValueZero(_p_.[[AsyncContextKey]], _asyncVariable_) is *false*, then
              1. Let _q_ be the Async Context Mapping Record { [[AsyncContextKey]]: _p_.[[AsyncContextKey]], [[AsyncContextValue]]: _p_.[[AsyncContextValue]] }.
              1. Append _q_ to _asyncContextMapping_.
          1. Assert: _asyncContextMapping_ does not contain an Async Context Mapping Record whose [[AsyncContextKey]] is _asyncVariable_.
          1. Let _p_ be the Async Context Mapping Record { [[AsyncContextKey]]: _asyncVariable_, [[AsyncContextValue]]: _value_ }.
          1. Append _p_ to _asyncContextMapping_.
          1. AsyncContextSwap(_asyncContextMapping_).
          1. Let _result_ be Completion(Call(_func_, *undefined*, _args_)).
          1. AsyncContextSwap(_previousContextMapping_).
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asynccontext-variable.prototype.name">
        <h1>get AsyncContext.Variable.prototype.name</h1>
        <p>`AsyncContext.Variable.prototype.name` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _asyncVariable_ be the *this* value.
          1. Perform ? RequireInternalSlot(_asyncVariable_, [[AsyncVariableName]]).
          1. Return _asyncVariable_.[[AsyncVariableName]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asynccontext-variable.prototype.get">
        <h1>AsyncContext.Variable.prototype.get ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _asyncVariable_ be the *this* value.
          1. Perform ? RequireInternalSlot(_asyncVariable_, [[AsyncVariableDefaultValue]]).
          1. Let _agentRecord_ be the surrounding agent's Agent Record.
          1. Let _asyncContextMapping_ be _agentRecord_.[[AsyncContextMapping]].
          1. For each Async Context Mapping Record _p_ of _asyncContextMapping_, do
            1. If SameValueZero(_p_.[[AsyncContextKey]], _asyncVariable_) is *true*, return _p_.[[AsyncContextValue]].
          1. Return _asyncVariable_.[[AsyncVariableDefaultValue]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asynccontext-variable.prototype-@@tostringtag">
        <h1>AsyncContext.Variable.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value *"AsyncContext.Variable"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-asynccontext-variable-instances">
      <h1>Properties of AsyncContext.Variable Instances</h1>
      <p>AsyncContext.Variable instances are ordinary objects that inherit properties from the AsyncContext.Variable prototype object (the intrinsic, %AsyncContext.Variable.prototype%). AsyncContext.Variable instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-asynccontext-variable-instances"></emu-xref>.</p>

      <emu-table id="table-internal-slots-of-asynccontext-variable-instances" caption="Internal Slots of AsyncContext.Variable Instances">
        <table>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Type
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[AsyncVariableName]]
            </td>
            <td>
              a String
            </td>
            <td>
              The name of the AsyncContext.Variable instance.
            </td>
          </tr>
          <tr>
            <td>
              [[AsyncVariableDefaultValue]]
            </td>
            <td>
              an ECMAScript language value
            </td>
            <td>
              The default value of the AsyncContext.Variable instance when no entry is found in the mapping.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>
  </emu-clause>
  </ins>
</emu-clause>

<emu-clause id="sec-managing-memory">
  <h1>Managing Memory</h1>

  <emu-clause id="sec-finalization-registry-objects">
    <h1>FinalizationRegistry Objects</h1>
    <p>A FinalizationRegistry is an object that manages registration and unregistration of cleanup operations that are performed when target objects and symbols are garbage collected.</p>

    <emu-clause id="sec-properties-of-the-finalization-registry-prototype-object">
      <h1>Properties of the FinalizationRegistry Prototype Object</h1>
      <p>The <dfn>FinalizationRegistry prototype</dfn> object:</p>
      <ul>
        <li>is <dfn>%FinalizationRegistry.prototype%</dfn>.</li>
        <li>
          has a [[Prototype]] internal slot whose value is %Object.prototype%.
        </li>
        <li>is an ordinary object.</li>
        <li>
          does not have [[Cells]] and [[CleanupCallback]] internal slots.
        </li>
      </ul>

      <emu-clause id="sec-finalization-registry.prototype.register">
        <h1>FinalizationRegistry.prototype.register ( _target_, _heldValue_ [ , _unregisterToken_ ] )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _finalizationRegistry_ be the *this* value.
          1. Perform ? RequireInternalSlot(_finalizationRegistry_, [[Cells]]).
          1. If CanBeHeldWeakly(_target_) is *false*, throw a *TypeError* exception.
          1. If SameValue(_target_, _heldValue_) is *true*, throw a *TypeError* exception.
          1. If CanBeHeldWeakly(_unregisterToken_) is *false*, then
            1. If _unregisterToken_ is not *undefined*, throw a *TypeError* exception.
            1. Set _unregisterToken_ to ~empty~.
          1. <del>Let _cell_ be the Record { [[WeakRefTarget]]: _target_, [[HeldValue]]: _heldValue_, [[UnregisterToken]]: _unregisterToken_ }.</del>
          1. <ins>Let _snapshot_ be AsyncContextSnapshot().</ins>
          1. <ins>Let _cell_ be the Record { [[WeakRefTarget]]: _target_, [[HeldValue]]: _heldValue_, [[UnregisterToken]]: _unregisterToken_, [[AsyncContextSnapshot]]: _snapshot_ }.</ins>
          1. Append _cell_ to _finalizationRegistry_.[[Cells]].
          1. Return *undefined*.
        </emu-alg>

        <emu-note>
          <p>Based on the algorithms and definitions in this specification, _cell_.[[HeldValue]] is live when _finalizationRegistry_.[[Cells]] contains _cell_; however, this does not necessarily mean that _cell_.[[UnregisterToken]] or _cell_.[[Target]] are live. For example, registering an object with itself as its unregister token would not keep the object alive forever.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-finalization-registry.prototype.unregister">
        <h1>FinalizationRegistry.prototype.unregister ( _unregisterToken_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _finalizationRegistry_ be the *this* value.
          1. Perform ? RequireInternalSlot(_finalizationRegistry_, [[Cells]]).
          1. If CanBeHeldWeakly(_unregisterToken_) is *false*, throw a *TypeError* exception.
          1. Let _removed_ be *false*.
          1. For each Record { [[WeakRefTarget]], [[HeldValue]], [[UnregisterToken]], <ins>[[AsyncContextSnapshot]]</ins> } _cell_ of _finalizationRegistry_.[[Cells]], do
            1. If _cell_.[[UnregisterToken]] is not ~empty~ and SameValue(_cell_.[[UnregisterToken]], _unregisterToken_) is *true*, then
              1. Remove _cell_ from _finalizationRegistry_.[[Cells]].
              1. Set _removed_ to *true*.
          1. Return _removed_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>
